# Clean Code

## Chapter 2. Meaningful Names

### Use Intention-Revealing Names

- 변수나 함수 그리고 클래스와 같은 코드의 각 요소는 그 의도를 분명히 드러낼 수 있어야 한다.
- 의도가 잘 전해지는 이름은 코드의 이해와 변경을 용이하게 만든다.
- 이름의 길이는 코드의 단순성에 영향을 미치지 않는다.

### Avoid Disinformation

- 잘못된 단서는 코드의 이해를 어렵게 만든다.
- 예시로, 널리 쓰이는 단어를 다른 의미로 사용할 경우 독자는 이를 잘못 이해할 수 있다.
- 또한, 서로 흡사한 이름을 사용할 경우 독자는 읽기에 어려움을 느낀다.

### Make Meaningful Distinctions

- 오직 컴파일러의 불평 불만을 피하기 위해 이름을 짓거나, noise words를 추가하는 방식으로 이름을 짓는 것은 적절하지 않다.
- 예시로, 같은 namespace에서의 변수 중복을 막기 위해 연속된 숫자를 뒤에 붙이는 방식은 코드의 의도를 전혀 전달하지 못한다.
- 또한, `variable`이나 `string` 같은 불용어를 이름에 포함하는 것은 도움이 되지 못한다.
- 그러므로 읽는 사람이 차이를 알도록 이름을 지어야 한다.

### Use Pronounceable Names

- 발음하기 쉬운 단어가 두뇌에서 처리하기 쉽다.
- 또한 발음하기 어려운 이름은 토론하기도 어렵다.

### Use Searchable Names

- 숫자로 이루어진 이름이나 한 글자로 이루어진 이름은 코드에서 검색하기 어렵다.
- 하나의 상수나 변수를 여러 곳에서 이용한다면 검색하기 쉬운 단어를 쓰는 것이 적합하다.

### Avoid Encodings

- 변수 이름을 인코딩 하기 위한 규칙을 만드는 것은 불필요한 부담을 요구한다.
- 과거에는 헝가리식 표기법과 같이 변수 이름에 타입 정보를 넣어야 했으나, 다양한 타입을 지원하는 현대 언어에서 그럴 필요는 없다.
- 멤버 변수를 구분하기 위한 접두어를 붙이는 것은 과거의 산물이다.
- 인터페이스보다는 구현 클래스에 인코딩을 적용하는 것이 추상화의 관점에서 좋다.

### Avoid Mental Mapping

- 독자는 자기가 알고 있는 다른 이름으로 코드의 이름을 해석할 필요가 없다.
- 즉, 코드를 명료하게 작성하는 것이 중요하다.

### Class Names

- 클래스나 객체 이름은 명사나 명사구가 적합하며, 동사는 사용하지 않는다.

### Method Names

- 메서드 이름은 동사나 동사구가 적합하며, javabean 표준을 따르는 것도 좋다.
- 생성자를 중복 정의할 때는 정적 팩토리 메서드를 이용하는 것이 좋다.

### Don’t Be Cute

- 재미난 이름보다는 명료한 이름이 좋다.
- 농담으로 이름을 짓는 것은 명료하지 못하며, 특정 문화에서만 사용하는 농담은 더더욱 피하는 것이 좋다.

### Pick One Word per Concept

- 추상적인 개념 하나에 단어 하나를 고수하자.
  - 예를 들어, `get`, `fetch`, `retreive`를 섞어 쓰는 것은 혼란을 야기한다.
- 일관성 있는 어휘가 읽기 쉬운 코드를 만든다.

### Don’t Pun

- 한 단어를 두 가지 목적으로 사용하는 것은 말장난에 불과하다.
- 같은 맥락이 아닌데도 일관성을 고려하여 앞서 사용한 단어를 채택하는 것은 혼란을 야기한다.

### Use Solution Domain Names

- 코드를 읽을 사람도 프로그래머이기에, 전산 용어나 수학 용어 등 도메인의 단어를 이용해도 괜찮다.
- 기술 개념에는 기술 이름이 제일 적합하다.

### Use Problem Domain Names

- 문제 도메인에서 이름을 가져오는 것도 좋은 선택이다.

### Add Meaningful Context

- 클래스, 함수, 네임스페이스 등을 통해 이름에 맥락을 부여할 수 있다.
- 만약 위 방법으로 실패했다면 마지막 수단으로 접두어를 고려해볼 수 있다.

### Don’t Add Gratuitous Context

- 의미가 분명하다면 짧은 이름이 긴 이름보다 좋다.
- 즉, 이름에 불필요한 맥락을 추가하지 않는 것이 좋다.

## Chapter 3. Functions

### Small

- 함수를 만드는 첫번째 규칙은 작아야만 한다는 것이다.
- 중첩 구조가 생길 만큼 커진 함수는 읽고 이해하기 어렵다.
- 더 나아가, `if`나 `else` 그리고 `while` 등에 들어가는 블록도 작아야한다.

### Do One Thing

- 함수는 한 가지만 해야하며, 그 한 가지를 잘 해야한다.
- 추상화 수준이 하나의 단계라면 그 함수는 하나의 일을 한다.
- 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 수행하고 있다고 생각할 수 있다.

### One Level of Abstraction per Function

- 함수 내 모든 문장의 추상화 수준은 동일해야 한다.
- 한 함수 내에 추상화 수준을 섞으면 이해하기 어렵다.
- 위에서 아래로 갈 수록 함수의 추상화 수준이 한 단계씩 낮아지는 것이 좋다.

### Switch Statements

- `switch` 구문을 작게 만드는 것이나 하나만 하게 하는 것은 어렵다.
- `switch` 구문을 피할 수 없다면, 추상화 시켜서 반복되지 않도록 만들어라.

### Use Descriptive Names

- 이름이 길어져도 괜찮으니 서술적인 이름을 택해라.
- 긴 이름이 짧고 이해하기 어려운 이름보다 좋다.
- 서술적인 이름은 설계를 뚜렷하게 만들어주며, 코드를 개선하기도 쉽게 만든다.

### Function Arguments

- 인수의 개수가 적을수록 좋다.
- 인수에 대한 질문을 던지거나, 인수를 변환해 결과를 반환하거나, 이벤트를 쓸 때가 아니라면 단항 함수는 피하는 것이 좋다.
- 플래그 인수는 해당 함수가 여러 일을 처리하는 것을 암시하기에 좋지 않다.
- 이항 함수는 단항 함수보다 이해하기 어렵지만, 더 적절한 경우도 있다.
- 삼항 함수는 이항 함수보다 이해하기 어렵다.
- 인수가 여러개 필요하다면 객체로 묶어서 패스해보는 방법도 있다.
- 상황에 따라서 가변 인수를 취하는 함수를 단항, 이항, 삼항 함수로 생각할 수 있으며, 이를 넘어서 인수를 사용하는 것은 좋지 않다.
- 인수의 순서에 따라 함수 이름을 지으면 헷갈리지 않는다.

### Have No Side Effects

- 사이드 이펙트는 함수가 시간에 종속되는 문제를 초래하며, 순서에 종속되게 만든다.
- 시간에 종속되는 함수는 함수 이름에 이를 분명히 명시해야 한다.
- 출력을 위한 인수는 피하는 것이 좋다.

### Command Query Separation

- 상태를 변경하거나 정보를 반환하는 행위를 하나의 함수가 하는 것은 혼란을 야기한다.
- 명령과 조회를 분리해 혼란을 없애는 것이 좋다.

### Prefer Exceptions to Returning Error Codes

- 오류 코드를 반환하기 보다 예외를 이용하는 것이 깔끔한 코드를 만든다.
- 호출자가 오류 코드를 처리해야 할 필요성을 없앤다.
- `try/catch` 블록은 별도의 함수로 뽑아내서 오류 처리 동작을 분리하는 변이 코드의 수정을 용이하게 만든다.
- 오류를 처리하는 함수는 오류를 처리하는 일만 해야한다.

### Don’t Repeat Yourself

- 중복은 코드 길이를 증가시킬 뿐만 아니라 수정을 어렵게 만들며, 오류가 일어날 가능성을 높인다.

### Structured Programming

- 모든 함수는 하나의 입구와 하나의 출구를 가져야하며, `break`, `continue`, `goto`와 같은 제어 구문은 사용하지 말아야 한다.
- 함수를 작게 만든다면 `return`, `break`, `continue`를 여러 차례 이용하는 것을 고려해볼 수 있다.

### How Do You Write Functions Like This?

- 코드를 작성하는 것은 글짓기와 비슷하여, 처음에는 코드가 길고 복잡할 수 있다.
- 그렇기에 코드를 작성한 후 고치고 다듬는 과정이 필요하다.

# Clean Code

## Chapter 2. Meaningful Names

### Use Intention-Revealing Names

- 변수나 함수 그리고 클래스와 같은 코드의 각 요소는 그 의도를 분명히 드러낼 수 있어야 한다.
- 의도가 잘 전해지는 이름은 코드의 이해와 변경을 용이하게 만든다.
- 이름의 길이는 코드의 단순성에 영향을 미치지 않는다.

### Avoid Disinformation

- 잘못된 단서는 코드의 이해를 어렵게 만든다.
- 예시로, 널리 쓰이는 단어를 다른 의미로 사용할 경우 독자는 이를 잘못 이해할 수 있다.
- 또한, 서로 흡사한 이름을 사용할 경우 독자는 읽기에 어려움을 느낀다.

### Make Meaningful Distinctions

- 오직 컴파일러의 불평 불만을 피하기 위해 이름을 짓거나, noise words를 추가하는 방식으로 이름을 짓는 것은 적절하지 않다.
- 예시로, 같은 namespace에서의 변수 중복을 막기 위해 연속된 숫자를 뒤에 붙이는 방식은 코드의 의도를 전혀 전달하지 못한다.
- 또한, `variable`이나 `string` 같은 불용어를 이름에 포함하는 것은 도움이 되지 못한다.
- 그러므로 읽는 사람이 차이를 알도록 이름을 지어야 한다.

### Use Pronounceable Names

- 발음하기 쉬운 단어가 두뇌에서 처리하기 쉽다.
- 또한 발음하기 어려운 이름은 토론하기도 어렵다.

### Use Searchable Names

- 숫자로 이루어진 이름이나 한 글자로 이루어진 이름은 코드에서 검색하기 어렵다.
- 하나의 상수나 변수를 여러 곳에서 이용한다면 검색하기 쉬운 단어를 쓰는 것이 적합하다.

### Avoid Encodings

- 변수 이름을 인코딩 하기 위한 규칙을 만드는 것은 불필요한 부담을 요구한다.
- 과거에는 헝가리식 표기법과 같이 변수 이름에 타입 정보를 넣어야 했으나, 다양한 타입을 지원하는 현대 언어에서 그럴 필요는 없다.
- 멤버 변수를 구분하기 위한 접두어를 붙이는 것은 과거의 산물이다.
- 인터페이스보다는 구현 클래스에 인코딩을 적용하는 것이 추상화의 관점에서 좋다.

### Avoid Mental Mapping

- 독자는 자기가 알고 있는 다른 이름으로 코드의 이름을 해석할 필요가 없다.
- 즉, 코드를 명료하게 작성하는 것이 중요하다.

### Class Names

- 클래스나 객체 이름은 명사나 명사구가 적합하며, 동사는 사용하지 않는다.

### Method Names

- 메서드 이름은 동사나 동사구가 적합하며, javabean 표준을 따르는 것도 좋다.
- 생성자를 중복 정의할 때는 정적 팩토리 메서드를 이용하는 것이 좋다.

### Don’t Be Cute

- 재미난 이름보다는 명료한 이름이 좋다.
- 농담으로 이름을 짓는 것은 명료하지 못하며, 특정 문화에서만 사용하는 농담은 더더욱 피하는 것이 좋다.

### Pick One Word per Concept

- 추상적인 개념 하나에 단어 하나를 고수하자.
  - 예를 들어, `get`, `fetch`, `retreive`를 섞어 쓰는 것은 혼란을 야기한다.
- 일관성 있는 어휘가 읽기 쉬운 코드를 만든다.

### Don’t Pun

- 한 단어를 두 가지 목적으로 사용하는 것은 말장난에 불과하다.
- 같은 맥락이 아닌데도 일관성을 고려하여 앞서 사용한 단어를 채택하는 것은 혼란을 야기한다.

### Use Solution Domain Names

- 코드를 읽을 사람도 프로그래머이기에, 전산 용어나 수학 용어 등 도메인의 단어를 이용해도 괜찮다.
- 기술 개념에는 기술 이름이 제일 적합하다.

### Use Problem Domain Names

- 문제 도메인에서 이름을 가져오는 것도 좋은 선택이다.

### Add Meaningful Context

- 클래스, 함수, 네임스페이스 등을 통해 이름에 맥락을 부여할 수 있다.
- 만약 위 방법으로 실패했다면 마지막 수단으로 접두어를 고려해볼 수 있다.

### Don’t Add Gratuitous Context

- 의미가 분명하다면 짧은 이름이 긴 이름보다 좋다.
- 즉, 이름에 불필요한 맥락을 추가하지 않는 것이 좋다.

## Chapter 3. Functions

### Small

- 함수를 만드는 첫번째 규칙은 작아야만 한다는 것이다.
- 중첩 구조가 생길 만큼 커진 함수는 읽고 이해하기 어렵다.
- 더 나아가, `if`나 `else` 그리고 `while` 등에 들어가는 블록도 작아야한다.

### Do One Thing

- 함수는 한 가지만 해야하며, 그 한 가지를 잘 해야한다.
- 추상화 수준이 하나의 단계라면 그 함수는 하나의 일을 한다.
- 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 수행하고 있다고 생각할 수 있다.

### One Level of Abstraction per Function

- 함수 내 모든 문장의 추상화 수준은 동일해야 한다.
- 한 함수 내에 추상화 수준을 섞으면 이해하기 어렵다.
- 위에서 아래로 갈 수록 함수의 추상화 수준이 한 단계씩 낮아지는 것이 좋다.

### Switch Statements

- `switch` 구문을 작게 만드는 것이나 하나만 하게 하는 것은 어렵다.
- `switch` 구문을 피할 수 없다면, 추상화 시켜서 반복되지 않도록 만들어라.

### Use Descriptive Names

- 이름이 길어져도 괜찮으니 서술적인 이름을 택해라.
- 긴 이름이 짧고 이해하기 어려운 이름보다 좋다.
- 서술적인 이름은 설계를 뚜렷하게 만들어주며, 코드를 개선하기도 쉽게 만든다.

### Function Arguments

- 인수의 개수가 적을수록 좋다.
- 인수에 대한 질문을 던지거나, 인수를 변환해 결과를 반환하거나, 이벤트를 쓸 때가 아니라면 단항 함수는 피하는 것이 좋다.
- 플래그 인수는 해당 함수가 여러 일을 처리하는 것을 암시하기에 좋지 않다.
- 이항 함수는 단항 함수보다 이해하기 어렵지만, 더 적절한 경우도 있다.
- 삼항 함수는 이항 함수보다 이해하기 어렵다.
- 인수가 여러개 필요하다면 객체로 묶어서 패스해보는 방법도 있다.
- 상황에 따라서 가변 인수를 취하는 함수를 단항, 이항, 삼항 함수로 생각할 수 있으며, 이를 넘어서 인수를 사용하는 것은 좋지 않다.
- 인수의 순서에 따라 함수 이름을 지으면 헷갈리지 않는다.

### Have No Side Effects

- 사이드 이펙트는 함수가 시간에 종속되는 문제를 초래하며, 순서에 종속되게 만든다.
- 시간에 종속되는 함수는 함수 이름에 이를 분명히 명시해야 한다.
- 출력을 위한 인수는 피하는 것이 좋다.

### Command Query Separation

- 상태를 변경하거나 정보를 반환하는 행위를 하나의 함수가 하는 것은 혼란을 야기한다.
- 명령과 조회를 분리해 혼란을 없애는 것이 좋다.

### Prefer Exceptions to Returning Error Codes

- 오류 코드를 반환하기 보다 예외를 이용하는 것이 깔끔한 코드를 만든다.
- 호출자가 오류 코드를 처리해야 할 필요성을 없앤다.
- `try/catch` 블록은 별도의 함수로 뽑아내서 오류 처리 동작을 분리하는 변이 코드의 수정을 용이하게 만든다.
- 오류를 처리하는 함수는 오류를 처리하는 일만 해야한다.

### Don’t Repeat Yourself

- 중복은 코드 길이를 증가시킬 뿐만 아니라 수정을 어렵게 만들며, 오류가 일어날 가능성을 높인다.

### Structured Programming

- 모든 함수는 하나의 입구와 하나의 출구를 가져야하며, `break`, `continue`, `goto`와 같은 제어 구문은 사용하지 말아야 한다.
- 함수를 작게 만든다면 `return`, `break`, `continue`를 여러 차례 이용하는 것을 고려해볼 수 있다.

### How Do You Write Functions Like This?

- 코드를 작성하는 것은 글짓기와 비슷하여, 처음에는 코드가 길고 복잡할 수 있다.
- 그렇기에 코드를 작성한 후 고치고 다듬는 과정이 필요하다.

## Chapter 4. Comments

### Comments Do Not Make Up for Bad Code

- 코드로 충분히 설명하지 못한 부분을 주석으로 설명하려고 하기 보다 코드를 깔끔하게 만드는 것이 좋다.

### Explain Yourself in Code

- 대부분의 경우에 코드만으로 의도를 표현할 수 있다.

### Good Comments

- Legal Comments
  - 법적인 정보, 계약 조건, 표준 라이선스 등을 주석으로 남기는 것은 필요하고 타당하다.
- Informative Comments
  - 기본적인 정보를 주석으로 제공하는 것도 때로는 편리하다. 하지만 함수 이름에 정보를 담는 편이 더 좋다.
- Explanation of Intent
  - 코드를 작성한 결정의 의도를 설명하는 주석은 유익하다.
- Clarification
  - 인수나 반환 값이 라이브러리에 속한다면, 의미를 밝히기 위한 주석이 유용하다.
- Warning of Consequences
  - 다른 프로그래머에게 결과를 경고하기 위한 주석은 합리적이다.
- TODO Comments
  - 앞으로 미리 할 일을 `// TODO` 주석으로 적어두는 것은 협업에 용이하다.
- Amplification
  - 중요성을 강조하는 데에 이용될 수 있다.
- Javadocs in Public APIs
  - 잘 기술된 Javadocs는 다른 개발자들의 이해를 돕는다.

### Bad Comments

- Mumbling
  - 뜻을 알아내기 위해 결국 다른 코드를 찾아봐야 하는, 주절거림에 불과한 주석은 나쁜 주석이다.
- Redundant Comments
  - 주석이 코드보다 더 많은 정보를 제공하지 못하면 읽는 시간을 낭비시킬 뿐이다.
- Misleading Comments
  - 주석에 잘못된 정보가 담길 경우 디버깅이 어려워진다.
- Mandated Comments
  - 항상 주석을 달아야한다는 규칙은 코드의 가독성을 낮춘다.
- Journal Comments
  - 변경을 기록하는 일은 버전 관리 시스템이 할 일이다.
- Noise Comments
  - 너무나도 당연한 사실을 언급하는 주석은 필요 없다.
- Scary Noise
  - 역할이 없는 주석은 잡음에 불과하다.
- Don’t Use a Comment When You Can Use a Function or a Variable
  - 주석이 필요하지 않도록 코드를 개선하자.
- Position Markers
  - 배너 역할을 하는 주석이 유용한 경우는 드물다.
  - 배너는 매우 눈에 띄므로 반드시 필요할 때에만 사용하자.
- Closing Brace Comments
  - 닫는 괄호에 주석을 달아야겠다는 생각이 든다면, 중첩이 심해진 코드라는 뜻이니 함수를 줄이려 노력하자.
- Attributions and Bylines
  - 버전 관리 시스템에 기록하자.
- Commented-Out Code
  - 주석으로 처리된 코드는 다른 사람이 지우기 주저하게 만들며, 쓰이지 않는 코드가 쌓이게 만드는 주범이다.
- HTML Comments
  - HTML 주석은 에디터나 IDE에서도 읽기 힘들다.
  - HTML 태그를 삽입할 책임은 작성하자 아니라 도구에 있다.
- Nonlocal Information
  - 시스템의 전반적인 정보를 기술하지 않는 것이 좋다.
- Too Much Information
  - 주제와 관련없는 정보를 장황하게 서술하는 것은 필요하지 않다.
- Inobvious Connection
  - 주석과 코드의 관계가 명확하지 않으면 주석을 다는 의미가 없다.
- Function Headers
  - 긴 주석으로 설명해야 하는 함수보다 짧고 한 가지만 수행하는 함수가 더 좋다.
- Javadocs in Nonpublic Code
  - 공개하지 않을 코드라면 Javadocs는 코드만 산만하게 만들 뿐이다.

## Chapter 7. Error Handling

### Use Exceptions Rather Than Return Codes

- 오류 코드를 반환하기보다 예외를 발생시키는 편이 호출자 코드를 더 깔끔하게 만든다.
- 즉, 비즈니스 로직과 예외를 처리하는 로직을 분리할 수 있다.

### Write Your Try-Catch-Finally Statement First

- 예외가 발생할 코드를 작성할 때에는 먼저 try-catch-finally 블록을 작성하여 프로그램의 상태를 일관성 있게 유지할 수 있도록 해야 한다.
- 호출자가 기대하는 상태를 유지하기 쉬워진다.

### Use Unchecked Exceptions

- 확인된 예외는 호출 체인의 모든 함수의 시그니처를 수정해야하는 비용을 동반한다.
- 즉, 모든 함수가 하위 함수에서 발생시키는 예외의 종류를 알아야하기 때문에 캡슐화가 깨진다.

### Provide Context with Exceptions

- 예외에 전후 상황을 담아서 함께 던지는 것이 코드의 의도를 파악하는데 도움이 된다.

### Define Exception Classes in Terms of a Caller’s Needs

- 예를 들어, 외부 라이브러리 호출에서 발생할 수 있는 오류를 종류별로 핸들링하기 보다 하나로 묶어서 핸들링하는 것이 좋다.
- 왜냐하면 이 상황에서 우리가 예외를 잡을 구간은 어차피 하나이기 때문이다.
- 또한, 다른 API의 설계에 발목 잡히지 않는다.

### Define the Normal Flow

- 예외에 따른 중단이 코드를 장황하게 만든다면, 특수 사례 패턴을 통해 더 간결하게 만들 수 있다.

### Don’t Return Null

- `null`을 반환하는 코드는 작성해야할 코드를 증가시킬 뿐만 아니라 호출자에게 책임을 맡긴다.
- 외부 라이브러리가 `null`을 반환한다면 감싸서 예외를 던지거나 특수 사례 객체를 반환하자.

### Don’t Pass Null

- `null`을 인수로 받을 수 있도록 설계된 언어가 아니라면 `null`의 전달은 최대한 피해야한다.
